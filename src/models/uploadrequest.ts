/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";

/**
 * Configuration object for automatic video transcription with translation options.
 */
export type AutoTranscription = { translate?: Array<string> | undefined };

export const AutoTranscription$zodSchema: z.ZodType<
  AutoTranscription,
  z.ZodTypeDef,
  unknown
> = z.object({
  translate: z.array(z.string()).optional(),
}).describe(
  "Configuration object for automatic video transcription with translation options.",
);

export type AutoTranscriptionUnion = AutoTranscription | boolean;

export const AutoTranscriptionUnion$zodSchema: z.ZodType<
  AutoTranscriptionUnion,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => AutoTranscription$zodSchema),
  z.boolean(),
]);

/**
 * For all asset types, set to:
 *
 * @remarks
 * - manual to add the uploaded asset to a list of pending assets that can be moderated using the Admin API or the Cloudinary Console.
 * - perception_point to automatically moderate the uploaded asset using the Perception Point Malware Detection add-on.
 *
 * For images only, set to:
 * - webpurify to automatically moderate the uploaded image using the WebPurify Image Moderation add-on.
 * - aws_rek to automatically moderate the uploaded image using the Amazon Rekognition AI Moderation add-on.
 * - duplicate:<threshold> to detect if the same or a similar image already exists using the Cloudinary Duplicate Image Detection add-on. Set threshold to a float greater than 0 and less than or equal to 1.0 to specify how similar an image needs to be in order to be considered a duplicate. Set threshold to 0 to add an image to the index of images that are searched when duplicate detection is invoked for another image.
 *
 * For videos only, set to:
 * - aws_rek_video to automatically moderate the uploaded video using the Amazon Rekognition Video Moderation add-on.
 * - google_video_moderation automatically moderate the uploaded video using the Google AI Video Moderation add-on.
 *
 * To request multiple moderations in a single API call:
 * - Send the desired list of moderations as a pipe-separated string with manual moderation, if relevant, being last.
 *
 * Note: Rejected assets are automatically invalidated on the CDN within approximately ten minutes.
 */
export const UploadRequestModeration$zodSchema = z.enum([
  "manual",
  "webpurify",
  "metascan",
  "aws_rek",
  "aws_rek_video",
  "google_video_moderation",
  "perception_point",
  "duplicate",
  "cld",
]).describe(
  "For all asset types, set to:\n"
    + "- manual to add the uploaded asset to a list of pending assets that can be moderated using the Admin API or the Cloudinary Console.\n"
    + "- perception_point to automatically moderate the uploaded asset using the Perception Point Malware Detection add-on.\n"
    + "\n"
    + "For images only, set to:\n"
    + "- webpurify to automatically moderate the uploaded image using the WebPurify Image Moderation add-on.\n"
    + "- aws_rek to automatically moderate the uploaded image using the Amazon Rekognition AI Moderation add-on.\n"
    + "- duplicate:<threshold> to detect if the same or a similar image already exists using the Cloudinary Duplicate Image Detection add-on. Set threshold to a float greater than 0 and less than or equal to 1.0 to specify how similar an image needs to be in order to be considered a duplicate. Set threshold to 0 to add an image to the index of images that are searched when duplicate detection is invoked for another image.\n"
    + "\n"
    + "For videos only, set to:\n"
    + "- aws_rek_video to automatically moderate the uploaded video using the Amazon Rekognition Video Moderation add-on.\n"
    + "- google_video_moderation automatically moderate the uploaded video using the Google AI Video Moderation add-on.\n"
    + "\n"
    + "To request multiple moderations in a single API call:\n"
    + "- Send the desired list of moderations as a pipe-separated string with manual moderation, if relevant, being last.\n"
    + "\n"
    + "Note: Rejected assets are automatically invalidated on the CDN within approximately ten minutes.\n"
    + "",
);

export type UploadRequestModeration = z.infer<
  typeof UploadRequestModeration$zodSchema
>;

export type ResponsiveBreakpoint = {
  create_derived?: boolean | undefined;
  max_width?: number | undefined;
  min_width?: number | undefined;
  bytes_step?: number | undefined;
  max_images?: number | undefined;
  transformation?: string | undefined;
};

export const ResponsiveBreakpoint$zodSchema: z.ZodType<
  ResponsiveBreakpoint,
  z.ZodTypeDef,
  unknown
> = z.object({
  bytes_step: z.number().int().optional(),
  create_derived: z.boolean().optional(),
  max_images: z.number().int().optional(),
  max_width: z.number().int().optional(),
  min_width: z.number().int().optional(),
  transformation: z.string().optional(),
});

/**
 * The delivery type that defines if and how the uploaded asset is available for public delivery. By default, all uploaded assets are public (upload). Possible values are upload, authenticated, private or asset.
 */
export const UploadRequestType$zodSchema = z.enum([
  "upload",
  "authenticated",
  "private",
  "asset",
]).describe(
  "The delivery type that defines if and how the uploaded asset is available for public delivery. By default, all uploaded assets are public (upload). Possible values are upload, authenticated, private or asset.",
);

export type UploadRequestType = z.infer<typeof UploadRequestType$zodSchema>;

/**
 * Allows the asset to behave as if it's of the authenticated 'type' (see above) while still using the default 'upload' type in delivery URLs. The asset can later be made public by changing its access_mode via the Admin API, without having to update any delivery URLs. Valid values: public, and authenticated.
 *
 * @remarks
 *
 * @deprecated enum: The access_mode parameter is no longer supported. To restrict access to assets, you can use the access_control parameter.. Use access_control instead.
 */
export const UploadRequestAccessMode$zodSchema = z.enum([
  "public",
  "authenticated",
]).describe(
  "Allows the asset to behave as if it's of the authenticated 'type' (see above) while still using the default 'upload' type in delivery URLs. The asset can later be made public by changing its access_mode via the Admin API, without having to update any delivery URLs. Valid values: public, and authenticated.\n"
    + "",
);

export type UploadRequestAccessMode = z.infer<
  typeof UploadRequestAccessMode$zodSchema
>;

/**
 * A comma-separated list of the categorization add-ons to run on the asset. Set to google_tagging, google_video_tagging, imagga_tagging and/or aws_rek_tagging to automatically classify the scenes of the uploaded asset.
 */
export const UploadRequestCategorization$zodSchema = z.enum([
  "rekognition_scene",
  "imagga_tagging",
  "aws_rek_tagging",
  "google_video_tagging",
  "google_tagging",
  "visenze_recognition",
  "azure_video_indexer",
]).describe(
  "A comma-separated list of the categorization add-ons to run on the asset. Set to google_tagging, google_video_tagging, imagga_tagging and/or aws_rek_tagging to automatically classify the scenes of the uploaded asset.",
);

export type UploadRequestCategorization = z.infer<
  typeof UploadRequestCategorization$zodSchema
>;

/**
 * Set to adv_ocr to extract all text elements in an image as well as the bounding box coordinates of each detected element using the OCR text detection and extraction add-on.
 */
export const UploadRequestOcr$zodSchema = z.enum([
  "adv_ocr",
]).describe(
  "Set to adv_ocr to extract all text elements in an image as well as the bounding box coordinates of each detected element using the OCR text detection and extraction add-on.",
);

export type UploadRequestOcr = z.infer<typeof UploadRequestOcr$zodSchema>;

/**
 * Automatically remove the background of an image using an add-on.
 *
 * @remarks
 * - Set to cloudinary_ai to use the deep-learning based Cloudinary AI Background Removal add-on.
 * - Note: this feature has been superseded by background removal on the fly.
 * - Set to pixelz to use the human-powered Pixelz Remove-The-Background Editing add-on service.
 * Relevant for images only.
 */
export const UploadRequestBackgroundRemoval$zodSchema = z.enum([
  "cloudinary_ai",
  "remove_the_background",
  "pixelz",
]).describe(
  "Automatically remove the background of an image using an add-on.\n"
    + "- Set to cloudinary_ai to use the deep-learning based Cloudinary AI Background Removal add-on.\n"
    + "- Note: this feature has been superseded by background removal on the fly.\n"
    + "- Set to pixelz to use the human-powered Pixelz Remove-The-Background Editing add-on service.\n"
    + "Relevant for images only.\n"
    + "",
);

export type UploadRequestBackgroundRemoval = z.infer<
  typeof UploadRequestBackgroundRemoval$zodSchema
>;

export type UploadRequest = {
  api_key?: string | undefined;
  timestamp?: number | undefined;
  signature?: string | undefined;
  accessibility_analysis?: boolean | undefined;
  asset_folder?: string | undefined;
  async?: boolean | undefined;
  auto_chaptering?: boolean | undefined;
  auto_transcription?: AutoTranscription | boolean | undefined;
  cinemagraph_analysis?: boolean | undefined;
  colors?: boolean | undefined;
  context?: string | undefined;
  custom_coordinates?: string | undefined;
  display_name?: string | undefined;
  eager?: string | undefined;
  eager_async?: boolean | undefined;
  eager_notification_url?: string | undefined;
  face_coordinates?: string | undefined;
  faces?: boolean | undefined;
  headers?: string | undefined;
  invalidate?: boolean | undefined;
  media_metadata?: boolean | undefined;
  metadata?: string | undefined;
  moderation?: UploadRequestModeration | undefined;
  notification_url?: string | undefined;
  phash?: boolean | undefined;
  quality_analysis?: boolean | undefined;
  regions?: string | undefined;
  responsive_breakpoints?: Array<ResponsiveBreakpoint> | undefined;
  tags?: string | undefined;
  callback?: string | undefined;
  backup?: boolean | undefined;
  discard_original_filename?: boolean | undefined;
  overwrite?: boolean | undefined;
  return_delete_token?: boolean | undefined;
  type?: UploadRequestType | undefined;
  access_mode?: UploadRequestAccessMode | undefined;
  categorization?: UploadRequestCategorization | undefined;
  ocr?: UploadRequestOcr | undefined;
  raw_convert?: string | undefined;
  background_removal?: UploadRequestBackgroundRemoval | undefined;
  public_id?: string | undefined;
  transformation?: string | undefined;
  format?: string | undefined;
  proxy?: string | undefined;
  folder?: string | undefined;
  allowed_formats?: string | undefined;
  auto_tagging?: number | undefined;
  access_control?: string | undefined;
  eval?: string | undefined;
  detection?: string | undefined;
  filename_override?: string | undefined;
  public_id_prefix?: string | undefined;
  use_asset_folder_as_public_id_prefix?: boolean | undefined;
  unique_display_name?: boolean | undefined;
  visual_search?: boolean | undefined;
  use_filename_as_display_name?: boolean | undefined;
  use_filename?: boolean | undefined;
  unique_filename?: boolean | undefined;
  upload_preset?: string | undefined;
  on_success?: string | undefined;
  file: string;
};

export const UploadRequest$zodSchema: z.ZodType<
  UploadRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  access_control: z.string().optional(),
  access_mode: UploadRequestAccessMode$zodSchema.optional(),
  accessibility_analysis: z.boolean().optional(),
  allowed_formats: z.string().optional(),
  api_key: z.string().optional(),
  asset_folder: z.string().optional(),
  async: z.boolean().optional(),
  auto_chaptering: z.boolean().optional(),
  auto_tagging: z.number().optional(),
  auto_transcription: z.union([
    z.lazy(() => AutoTranscription$zodSchema),
    z.boolean(),
  ]).optional(),
  background_removal: UploadRequestBackgroundRemoval$zodSchema.optional(),
  backup: z.boolean().optional(),
  callback: z.string().optional(),
  categorization: UploadRequestCategorization$zodSchema.optional(),
  cinemagraph_analysis: z.boolean().optional(),
  colors: z.boolean().default(false),
  context: z.string().optional(),
  custom_coordinates: z.string().optional(),
  detection: z.string().optional(),
  discard_original_filename: z.boolean().optional(),
  display_name: z.string().optional(),
  eager: z.string().optional(),
  eager_async: z.boolean().optional(),
  eager_notification_url: z.string().optional(),
  eval: z.string().optional(),
  face_coordinates: z.string().optional(),
  faces: z.boolean().optional(),
  file: z.string(),
  filename_override: z.string().optional(),
  folder: z.string().optional(),
  format: z.string().optional(),
  headers: z.string().optional(),
  invalidate: z.boolean().optional(),
  media_metadata: z.boolean().optional(),
  metadata: z.string().optional(),
  moderation: UploadRequestModeration$zodSchema.optional(),
  notification_url: z.string().optional(),
  ocr: UploadRequestOcr$zodSchema.optional(),
  on_success: z.string().optional(),
  overwrite: z.boolean().optional(),
  phash: z.boolean().optional(),
  proxy: z.string().optional(),
  public_id: z.string().optional(),
  public_id_prefix: z.string().optional(),
  quality_analysis: z.boolean().optional(),
  raw_convert: z.string().optional(),
  regions: z.string().optional(),
  responsive_breakpoints: z.array(z.lazy(() => ResponsiveBreakpoint$zodSchema))
    .optional(),
  return_delete_token: z.boolean().optional(),
  signature: z.string().optional(),
  tags: z.string().optional(),
  timestamp: z.number().int().optional(),
  transformation: z.string().optional(),
  type: UploadRequestType$zodSchema.optional(),
  unique_display_name: z.boolean().optional(),
  unique_filename: z.boolean().optional(),
  upload_preset: z.string().optional(),
  use_asset_folder_as_public_id_prefix: z.boolean().optional(),
  use_filename: z.boolean().optional(),
  use_filename_as_display_name: z.boolean().optional(),
  visual_search: z.boolean().optional(),
});
