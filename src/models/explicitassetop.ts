/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { ApiError, ApiError$zodSchema } from "./apierror.js";
import {
  ArchiveStorageType,
  ArchiveStorageType$zodSchema,
} from "./archivestoragetype.js";
import { ResourceType, ResourceType$zodSchema } from "./resourcetype.js";
import { UploadResponse, UploadResponse$zodSchema } from "./uploadresponse.js";

export type ExplicitAssetGlobals = { cloud_name?: string | undefined };

export const ExplicitAssetGlobals$zodSchema: z.ZodType<
  ExplicitAssetGlobals,
  z.ZodTypeDef,
  unknown
> = z.object({
  cloud_name: z.string().describe("The cloud name of your product environment.")
    .optional(),
});

/**
 * Configuration object for automatic video transcription with translation options.
 */
export type ExplicitAssetAutoTranscription = {
  translate?: Array<string> | undefined;
};

export const ExplicitAssetAutoTranscription$zodSchema: z.ZodType<
  ExplicitAssetAutoTranscription,
  z.ZodTypeDef,
  unknown
> = z.object({
  translate: z.array(z.string()).optional(),
}).describe(
  "Configuration object for automatic video transcription with translation options.",
);

export type ExplicitAssetAutoTranscriptionUnion =
  | ExplicitAssetAutoTranscription
  | boolean;

export const ExplicitAssetAutoTranscriptionUnion$zodSchema: z.ZodType<
  ExplicitAssetAutoTranscriptionUnion,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => ExplicitAssetAutoTranscription$zodSchema),
  z.boolean(),
]);

/**
 * For all asset types, set to:
 *
 * @remarks
 * - manual to add the uploaded asset to a list of pending assets that can be moderated using the Admin API or the Cloudinary Console.
 * - perception_point to automatically moderate the uploaded asset using the Perception Point Malware Detection add-on.
 *
 * For images only, set to:
 * - webpurify to automatically moderate the uploaded image using the WebPurify Image Moderation add-on.
 * - aws_rek to automatically moderate the uploaded image using the Amazon Rekognition AI Moderation add-on.
 * - duplicate:<threshold> to detect if the same or a similar image already exists using the Cloudinary Duplicate Image Detection add-on. Set threshold to a float greater than 0 and less than or equal to 1.0 to specify how similar an image needs to be in order to be considered a duplicate. Set threshold to 0 to add an image to the index of images that are searched when duplicate detection is invoked for another image.
 *
 * For videos only, set to:
 * - aws_rek_video to automatically moderate the uploaded video using the Amazon Rekognition Video Moderation add-on.
 * - google_video_moderation automatically moderate the uploaded video using the Google AI Video Moderation add-on.
 *
 * To request multiple moderations in a single API call:
 * - Send the desired list of moderations as a pipe-separated string with manual moderation, if relevant, being last.
 *
 * Note: Rejected assets are automatically invalidated on the CDN within approximately ten minutes.
 */
export const ExplicitAssetModeration$zodSchema = z.enum([
  "manual",
  "webpurify",
  "metascan",
  "aws_rek",
  "aws_rek_video",
  "google_video_moderation",
  "perception_point",
  "duplicate",
  "cld",
]).describe(
  "For all asset types, set to:\n"
    + "- manual to add the uploaded asset to a list of pending assets that can be moderated using the Admin API or the Cloudinary Console.\n"
    + "- perception_point to automatically moderate the uploaded asset using the Perception Point Malware Detection add-on.\n"
    + "\n"
    + "For images only, set to:\n"
    + "- webpurify to automatically moderate the uploaded image using the WebPurify Image Moderation add-on.\n"
    + "- aws_rek to automatically moderate the uploaded image using the Amazon Rekognition AI Moderation add-on.\n"
    + "- duplicate:<threshold> to detect if the same or a similar image already exists using the Cloudinary Duplicate Image Detection add-on. Set threshold to a float greater than 0 and less than or equal to 1.0 to specify how similar an image needs to be in order to be considered a duplicate. Set threshold to 0 to add an image to the index of images that are searched when duplicate detection is invoked for another image.\n"
    + "\n"
    + "For videos only, set to:\n"
    + "- aws_rek_video to automatically moderate the uploaded video using the Amazon Rekognition Video Moderation add-on.\n"
    + "- google_video_moderation automatically moderate the uploaded video using the Google AI Video Moderation add-on.\n"
    + "\n"
    + "To request multiple moderations in a single API call:\n"
    + "- Send the desired list of moderations as a pipe-separated string with manual moderation, if relevant, being last.\n"
    + "\n"
    + "Note: Rejected assets are automatically invalidated on the CDN within approximately ten minutes.\n"
    + "",
);

export type ExplicitAssetModeration = z.infer<
  typeof ExplicitAssetModeration$zodSchema
>;

export type ExplicitAssetResponsiveBreakpoint = {
  create_derived?: boolean | undefined;
  max_width?: number | undefined;
  min_width?: number | undefined;
  bytes_step?: number | undefined;
  max_images?: number | undefined;
  transformation?: string | undefined;
};

export const ExplicitAssetResponsiveBreakpoint$zodSchema: z.ZodType<
  ExplicitAssetResponsiveBreakpoint,
  z.ZodTypeDef,
  unknown
> = z.object({
  bytes_step: z.number().int().optional(),
  create_derived: z.boolean().optional(),
  max_images: z.number().int().optional(),
  max_width: z.number().int().optional(),
  min_width: z.number().int().optional(),
  transformation: z.string().optional(),
});

/**
 * Override the quality setting for this asset.
 */
export type QualityOverride = string | number;

export const QualityOverride$zodSchema: z.ZodType<
  QualityOverride,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.string(),
  z.number().int(),
]).describe("Override the quality setting for this asset.");

export type ExplicitAssetRequestBody = {
  api_key?: string | undefined;
  timestamp?: number | undefined;
  signature?: string | undefined;
  accessibility_analysis?: boolean | undefined;
  asset_folder?: string | undefined;
  async?: boolean | undefined;
  auto_chaptering?: boolean | undefined;
  auto_transcription?: ExplicitAssetAutoTranscription | boolean | undefined;
  cinemagraph_analysis?: boolean | undefined;
  colors?: boolean | undefined;
  context?: string | undefined;
  custom_coordinates?: string | undefined;
  display_name?: string | undefined;
  eager?: string | undefined;
  eager_async?: boolean | undefined;
  eager_notification_url?: string | undefined;
  face_coordinates?: string | undefined;
  faces?: boolean | undefined;
  headers?: string | undefined;
  invalidate?: boolean | undefined;
  media_metadata?: boolean | undefined;
  metadata?: string | undefined;
  moderation?: ExplicitAssetModeration | undefined;
  notification_url?: string | undefined;
  phash?: boolean | undefined;
  quality_analysis?: boolean | undefined;
  regions?: string | undefined;
  responsive_breakpoints?: Array<ExplicitAssetResponsiveBreakpoint> | undefined;
  tags?: string | undefined;
  callback?: string | undefined;
  public_id: string;
  type?: ArchiveStorageType | undefined;
  overwrite?: boolean | undefined;
  quality_override?: string | number | undefined;
};

export const ExplicitAssetRequestBody$zodSchema: z.ZodType<
  ExplicitAssetRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  accessibility_analysis: z.boolean().optional(),
  api_key: z.string().optional(),
  asset_folder: z.string().optional(),
  async: z.boolean().optional(),
  auto_chaptering: z.boolean().optional(),
  auto_transcription: z.union([
    z.lazy(() => ExplicitAssetAutoTranscription$zodSchema),
    z.boolean(),
  ]).optional(),
  callback: z.string().optional(),
  cinemagraph_analysis: z.boolean().optional(),
  colors: z.boolean().default(false),
  context: z.string().optional(),
  custom_coordinates: z.string().optional(),
  display_name: z.string().optional(),
  eager: z.string().optional(),
  eager_async: z.boolean().optional(),
  eager_notification_url: z.string().optional(),
  face_coordinates: z.string().optional(),
  faces: z.boolean().optional(),
  headers: z.string().optional(),
  invalidate: z.boolean().optional(),
  media_metadata: z.boolean().optional(),
  metadata: z.string().optional(),
  moderation: ExplicitAssetModeration$zodSchema.optional(),
  notification_url: z.string().optional(),
  overwrite: z.boolean().optional(),
  phash: z.boolean().optional(),
  public_id: z.string(),
  quality_analysis: z.boolean().optional(),
  quality_override: z.union([
    z.string(),
    z.number().int(),
  ]).optional(),
  regions: z.string().optional(),
  responsive_breakpoints: z.array(
    z.lazy(() => ExplicitAssetResponsiveBreakpoint$zodSchema),
  ).optional(),
  signature: z.string().optional(),
  tags: z.string().optional(),
  timestamp: z.number().int().optional(),
  type: ArchiveStorageType$zodSchema.optional(),
});

export type ExplicitAssetRequest = {
  resource_type: ResourceType;
  RequestBody: ExplicitAssetRequestBody;
};

export const ExplicitAssetRequest$zodSchema: z.ZodType<
  ExplicitAssetRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  RequestBody: z.lazy(() => ExplicitAssetRequestBody$zodSchema),
  resource_type: ResourceType$zodSchema,
});

export type ExplicitAssetResponse = {
  ContentType: string;
  StatusCode: number;
  RawResponse: Response;
  upload_response?: UploadResponse | undefined;
  api_error?: ApiError | undefined;
};

export const ExplicitAssetResponse$zodSchema: z.ZodType<
  ExplicitAssetResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  ContentType: z.string(),
  RawResponse: z.instanceof(Response),
  StatusCode: z.number().int(),
  api_error: ApiError$zodSchema.optional(),
  upload_response: UploadResponse$zodSchema.optional(),
});
